#!/usr/bin/env python3

description = '''
fg-gensol is an executable that generates initial magnetization configurations (`sol.in` files) for
feeLLGood simulations from Gmsh mesh files. It automatically detects physical volume regions in the
input mesh and allows to define custom vector fields for each region.
'''

import socket 
import os
import sys
import numpy as np
import meshio

from datetime import datetime
import warnings

warnings.simplefilter("always")
warnings.formatwarning = lambda message, category, filename, lineno, line=None: f"{message}\n"

DEBUG = 1

def autogenerate_init_cfg(regions):
    """
    Automatically generates the init_cfg.py module containing
    the define_region_functions() function for all detected regions.
    """
    filename = "init_cfg.py"
    
    region_lines = []
    for region_name in sorted(regions.keys()):
        line = f"        '{region_name}': lambda x, y, z: np.array([0, 0, 1]),"
        region_lines.append(line)

    module_content = [
        "#!/usr/bin/env python3",
        "# Auto-generated configuration module",
        "# Edit the lambda functions below to define magnetization vector field for each region",
        "",
        "import numpy as np",
        "",
        "",
        "def define_region_functions():",
        '    """Define magnetization vector field for each region (autogenerated)."""',
        "    return {",
        *region_lines,
        "    }",
        ""
    ]

    with open(filename, "w", encoding="utf-8") as f:
        f.write("\n".join(module_content))

    print(f"✅ Module 'init_cfg.py' created with {len(regions)} regions.")
    print("➡️  Edit init_cfg.py to define magnetization vector fields for each region.")
    print("➡️  Then run the script again to generate the sol.in file.")


def get_region_elements(mesh):
    """
    Return a dictionary mapping region name -> list of element descriptions.
    Only includes volume elements (tetrahedra).
    """
    if not hasattr(mesh, "cells"):
        raise ValueError("mesh has no attribute 'cells'")

    # 1) build mapping physical_id -> (region_name, dimension)
    id_to_name = {}
    for name, arr in mesh.field_data.items():
        try:
            arr_flat = np.asarray(arr).flatten()
            phys_id = int(arr_flat[0])
            dimension = int(arr_flat[1]) if len(arr_flat) > 1 else None
            # Only keep 3D regions (volume)
            if dimension == 3:
                id_to_name[phys_id] = name
                print(f"  Volume region: {name} (ID={phys_id}, dim={dimension})")
        except Exception:
            continue
    
    if not id_to_name:
        raise ValueError("No volume regions (dimension=3) found in mesh")
    
    print("Volume regions only:", id_to_name)
    
    # 2) find physical tags key
    phys_key = None
    if hasattr(mesh, "cell_data") and mesh.cell_data:
        for k in mesh.cell_data.keys():
            if k == "gmsh:physical":
                phys_key = k
                break
        if phys_key is None:
            for k in mesh.cell_data.keys():
                if "physical" in k.lower():
                    phys_key = k
                    break

    if phys_key is None:
        raise ValueError("No physical tags found in mesh.cell_data.")

    # 3) iterate cell blocks - only process volume elements
    regions = {}
    global_idx = 0
    phys_tags_list = mesh.cell_data[phys_key]
    
    if len(phys_tags_list) != len(mesh.cells):
        raise ValueError(f"Mismatch between cell blocks and cell_data for key '{phys_key}'")

    for block_index, (cell_block, phys_tags) in enumerate(zip(mesh.cells, phys_tags_list)):
        cell_type = cell_block.type
        connectivity = np.asarray(cell_block.data, dtype=int)
        phys_tags = np.asarray(phys_tags, dtype=int).flatten()

        if connectivity.shape[0] != phys_tags.shape[0]:
            raise ValueError(f"Element count mismatch in block {block_index}")

        for local_idx in range(connectivity.shape[0]):
            phys_id = int(phys_tags[local_idx])
            # Only process if this physical ID is in our volume regions
            if phys_id not in id_to_name:
                continue
                
            region_name = id_to_name[phys_id]
            elem = {
                "cell_type": cell_type,
                "block_index": block_index,
                "local_element_index": local_idx,
                "global_element_index": global_idx,
                "nodes": connectivity[local_idx].tolist()
            }
            regions.setdefault(region_name, []).append(elem)
            global_idx += 1

    return regions


def load_mesh(filename):
    """Load mesh and return points, triangles, tetrahedrons, regions."""
    if not os.path.isfile(filename):
        raise FileNotFoundError(f"File '{filename}' does not exist.")

    try:
        mesh = meshio.read(filename)
        print(mesh)
        
        # Display regions info
        for cell_block, cell_data in zip(mesh.cells, mesh.cell_data["gmsh:physical"]):
            cell_type = cell_block.type
            print(f"\nCell type: {cell_type}")
            for region_name, (region_id, dim) in mesh.field_data.items():
                element_indices = np.where(cell_data == region_id)[0]
                if len(element_indices) > 0:
                    print(f"  Region '{region_name}' (ID={region_id}, dim={dim}): {len(element_indices)} elements")

        regions = get_region_elements(mesh)
        
        if DEBUG: # assumption DEBUG set to 1
        # Display all element node indices for each region
            print('DEBUG')
            for region_name, elems in regions.items():
                print(f"\nRegion '{region_name}' — {len(elems)} elements:")
                for elem in elems:
                    print(f"  Element {elem['global_element_index']:4d} ({elem['cell_type']}): nodes {elem['nodes']}")
        
        points = mesh.points[:, :3]
        print('Number of nodes : ', len(points))

        return points, regions

    except Exception as e:
        raise RuntimeError(f"Error loading mesh '{filename}': {e}")


def apply_region_functions(points, regions, region_functions):
    """Apply region defined functions."""
    m = np.full((len(points), 3), np.nan, dtype=np.float64)
    
    for region_name, elems in regions.items():
        if region_name not in region_functions:
            warnings.warn(f"⚠️ No function defined for region '{region_name}'. Region ignored.")
            continue

        func = region_functions[region_name]
        for elem in elems:
            for node_id in elem['nodes']:
                idx = node_id # Meshio uses zero-based indexing
                xyz = points[idx, :]
                m[idx] = func(*xyz)

    norms = np.linalg.norm(m, axis=1)
    nonzero = norms > 0    
    m[nonzero] /= norms[nonzero][:, np.newaxis]
    
    if (np.linalg.norm(m, axis=1) == 0).any():
         warnings.warn(f"⚠️  m contains zero-norm vectors")

    if np.isnan(m).any():
        warnings.warn("m contains non-initialized values")
        sys.exit("❌ abort")

    return m


def write_solution_file(m, filename="sol.in"):
    """Write field m and metadata to sol.in file."""
    now = datetime.now().isoformat()
    hostname = socket.gethostname()
    
    header_lines = [
        "## generator: fg-gensol",
        f"## hostname: {hostname}",
        f"## real-world time: {now}",
        "## time: 0",
        "## columns: idx\tmx\tmy\tmz\tphi"
    ]

    idx = np.arange(m.shape[0])[:, np.newaxis]
    phi = np.zeros((m.shape[0], 1))
    tab = np.hstack((idx, m, phi))

    with open(filename, "w") as f:
        for line in header_lines:
            f.write(line + "\n")
        np.savetxt(f, tab, fmt=["%d", "%+.7e", "%+.7e", "%+.7e", "%.7e"], delimiter="\t")

    print(f"✅ File '{filename}' successfully written ({len(header_lines)} header lines and {m.shape[0]} data lines).")


def main(mesh_file):
    """Main routine."""
    points, regions = load_mesh(mesh_file)
    
    # Check if init_cfg.py exists in current directory
    init_cfg_path = os.path.abspath("init_cfg.py")
    if not os.path.isfile(init_cfg_path):
        print("⚠️  Module 'init_cfg.py' not found.")
        autogenerate_init_cfg(regions)
        sys.exit(0)
    
    # Add current directory to Python path if necessary
    current_dir = os.getcwd()
    if current_dir not in sys.path:
        sys.path.insert(0, current_dir)
    
    # Import init_cfg (with reload if already cached)
    try:
        if 'init_cfg' in sys.modules:
            import importlib
            import init_cfg
            importlib.reload(init_cfg)
        else:
            import init_cfg
        
        region_functions = init_cfg.define_region_functions()
        
        print(f"DEBUG: Regions in mesh: {sorted(regions.keys())}")
        print(f"DEBUG: Regions in init_cfg: {sorted(region_functions.keys())}")
        
        # Check that all regions have a function
        missing_regions = set(regions.keys()) - set(region_functions.keys())
        if missing_regions:
            print(f"⚠️  Missing regions in init_cfg.py: {missing_regions}")
            print("Regenerating init_cfg.py module...")
            autogenerate_init_cfg(regions)
            sys.exit(0)
        
        print("✅ All regions are defined, generating sol.in...")
        # If everything is OK, generate sol.in
        m = apply_region_functions(points, regions, region_functions)
        write_solution_file(m)
        
    except (AttributeError, Exception) as e:
        print(f"⚠️  Error importing 'init_cfg.py': {e}")
        import traceback
        traceback.print_exc()
        autogenerate_init_cfg(regions)
        sys.exit(0)

__version__ = '1.0.0'
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: ./fg-gensol.py mesh_file.msh")
        sys.exit(1)

    mesh_file = sys.argv[1]
    main(mesh_file)
